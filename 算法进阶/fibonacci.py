# 递归版本的斐波那契数列，使用递归速度很慢
# 为啥递归为慢呢？子问题的重复计算
# 假设n=5
# 1.是 f(4)+f(3) = f(5)
# 2.而 f(4) 是 f(3)+f(2) 的结果
# 注意1.与2.中的f(3)是独立的，都要去算一遍
# 我要f(5)，我就得算两个f(3) 以下是验算过程，
# 他们相互之间都是独立的，相同的问题计算了好多变
# f(5)=f(4)+f(3)
# f(4)=f(3)+f(2)
# f(3)=f(2)+f(1)
# f(3)=f(2)+f(1)
# f(2)=1
# f(2)=1
# f(2)=1
# 注意：不是所以有递归都会有子问题重复计算的情况，但斐波那契数列是有这个问题的
from cal_time import cal_time


@cal_time
def f(n):
    return fibonacci(n)


def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)


# 非递归版本的斐波那契数列，速度很快
# 不像递归版本那样重复计算，不递归是把计算出来的值直接存储
# 使用时直接访问即可
# 动态规划（DP）的思想 = 递推式 + 重复子问题
# 1.最优子结构[递推式f(n-1)+f(n-2)]：要解决这个问题，
# 只要解决它的子问题就好了，也就是找到他的递推试
# 2.重复子问题：下例就是把需要的子问题保存起来
@cal_time
def f_no_recursion(n):
    f = [0, 1, 1]  # 列表中的0只是为了保证计算时下标一致，没其它用
    if n > 2:  # 如果n是小于2的就直接返回了
        for i in range(n - 2):
            num = f[-1] + f[-2]  # 列表中倒数第二位加倒数第一位
            f.append(num)
    return f[n]

if __name__ == '__main__':
    n = 40
    print('当 n={} 时使用递归与动态规划的用时对比'.format(n))
    print(f(n))
    print(f_no_recursion(n))
