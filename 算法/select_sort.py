# 选择排序
from cal_time import *
"""
分为有序区与无序区，排好序的数据放在有序区
选择排序就是找到这个序列中最小/大的数，与无序区的第一个数进行交换即可
li=[3,2,4,1,5,6,8,7,9] 默认有序区一个值都没有，所有值都在无序区

第一次找到无序区最小/大的数与无序区的第一个数进行交换
[3,2,4,1,5,6,8,7,9] = [1,2,4,3,5,6,8,7,9]
3与1进行了交换 1在有序了，其它都在无序区中

第二次找到无序区最小/大的数与无序区的第一个数进行交换
[3,2,4,1,5,6,8,7,9] = [1,2,4,3,5,6,8,7,9]
2与2进行了交换 1，2在有序了，其它都在无序区中

第三次找到无序区最小/大的数与无序区的第一个数进行交换
[3,2,4,1,5,6,8,7,9] = [1,2,3,4,5,6,8,7,9]
4与3进行了交换 1,2,3在有序了，其它都在无序区中
"""

@cal_time
def select_sort(li):
    n = len(li)
    for i in range(n - 1):  # 与冒泡排序一样需要n-1趟 因为最后一个数不用进行交换，肯定是最大或最小的
        min_loc = i  # 保存目前已知的最小值的下标位置location，假定第一个就是最小值
        for j in range(i + 1, n):  # 每一趟都要遍历无序区，第0趟无序区的长度是从1到最后，
            # 第1趟是从1到最后，第i趟是从i到最后 i+1避免自己和自己比较，没意义，其实比较也无所谓
            if li[j] < li[min_loc]:  # 找到比min_loc记录还小的值了
                min_loc = j  # 交换下标
        li[i], li[min_loc] = li[min_loc], li[i]  # 比较完成后开始进行交换，3与1，2与2，4与3
        #print(li,li[min_loc], li[i],'交换')


if __name__ == '__main__':
    li = [3, 2, 4, 1, 5, 6, 8, 7, 9]
    select_sort(li)




